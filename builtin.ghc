% -*- coding:utf-8-unix; mode:prolog -*-
% ----------------------------------------------------------------------
% builtin predicates
% ----------------------------------------------------------------------

call(Goal) :- call_inline(Goal).

call_inline(Goal) :-
    inline('{'),
    inline('  MACRO_wait(reg::in(1));'),
    inline('  Q q = vm->in[1];'),
    inline('  const TAG_T tag = tag_of(q);'),
    inline('  if (tag == TAG_ATOM) {'),
    inline('    const int pc = prog->query_entry_point(q);'),
    inline('    MACRO_execute(pc, 0);'),
    inline('  } else if (tag == TAG_STR) {'),
    inline('    A* structure = ptr_of<A>(q);'),
    inline('    Q g = structure[0].load();'),
    inline('    const int pc = prog->query_entry_point(g);'),
    inline('    if (pc < 0) {'),
    inline('      vm->fail();'),
    inline('      continue;'),
    inline('    }'),
    inline('    const int arity = atom_arity_of(g);'),
    inline('    MACRO_tail(2);'),
    inline('    for (int i = 1; i <= arity; ++i) {'),
    inline('      MACRO_out_constant(structure[i].load(), reg::out(i));'),
    inline('    }'),
    inline('    MACRO_execute(pc, arity);'),
    inline('  }'),
    inline('}').

time(Goal) :-
    time_pre_inline(Start, Inferences),
    call(Goal)
    -> time_post_inline(Start, Inferences).

time_pre_inline(Start, Inferences) :-
    inline('{'),
    inline('  const int64_t istart = static_cast<int64_t>(std::clock() * 1000000.0 / CLOCKS_PER_SEC);'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(istart), reg::in(1));'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(vm->inferences), reg::in(2));'),
    inline('  MACRO_proceed;'),
    inline('}').

time_post_inline(Start, Inferences) :-
    inline('{'),
    inline('  const int64_t iend = static_cast<int64_t>(std::clock() * 1000000.0 / CLOCKS_PER_SEC);'),
    inline('  const int64_t istart ='),
    inline('          value_of<int64_t>(vm->in[1]);'),
    inline('  const int64_t inferences ='),
    inline('          vm->inferences - value_of<int64_t>(vm->in[2]);'),
    inline('  const double seconds = (iend - istart) / 1000000.0;'),
    inline('  std::cout << "% " << inferences << " inferences, "'),
    inline('            << seconds << " CPU seconds ("'),
    inline('            << std::fixed << (inferences / seconds) << " Lips)" << std::endl;'),
    inline('  MACRO_proceed;'),
    inline('}').

atom_number(A, N) :- atom(A) | atom_to_number_inline(A, N).
atom_number(A, N) :- integer(N) | number_to_atom_inline(A, N).

atom_to_number_inline(A, N) :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  const Q q = vm->in[1];'),
    inline('  const std::string s = atom_str_of(q);'),
    inline('  const int64_t i = std::stoll(s);'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(i), reg::in(2));'),
    inline('  MACRO_proceed;'),
    inline('}').

number_to_atom_inline(A, N) :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  const Q q = vm->in[2];'),
    inline('  const int64_t i = value_of<int64_t>(q);'),
    inline('  const std::string s = std::to_string(i);'),
    inline('  MACRO_get_constant(to_atom(s.c_str(), 0), reg::in(1));'),
    inline('  MACRO_proceed;'),
    inline('}').

writeln(X) :- write(X) -> nl.

nl :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  std::cout << std::endl;'),
    inline('  MACRO_proceed;'),
    inline('}').

write(X) :- integer(X) | write_number_inline(X).
write(X) :- atom(X) | write_atom_inline(X).
write(X) :- var(X) | write_var_inline(X).
write([]) :- write('[]').
write([A|B]) :- write('[') -> write(A) -> write_list_tail(B) -> write(']').
write(X) :-
    is_functor(X) |
    X =.. [F|Args] -> write(F) -> write_functor_args(Args).
write_functor_args([]) :- true.
otherwise.
write_functor_args(X) :- write('(') -> write_functor_args2(X) -> write(')').
write_functor_args2([]) :- true.
write_functor_args2([A|B]) :- write(A) -> write_functor_tail(B).
write_functor_tail([]) :- true.
write_functor_tail([A|B]) :- write(,) -> write(A) -> write_functor_tail(B).

write_list_tail([]) :- true.
write_list_tail([A|B]) :- write(',') -> write(A) -> write_list_tail(B).
otherwise.
write_list_tail(X) :- write('|') -> write(X).

write_number_inline(X) :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  const Q q = vm->in[1];'),
    inline('  const int64_t i = value_of<int64_t>(q);'),
    inline('  std::cout << i;'),
    inline('  MACRO_proceed;'),
    inline('}').
write_atom_inline(X) :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  const Q q = vm->in[1];'),
    inline('  const std::string s = atom_str_of(q);'),
    inline('  std::cout << s;'),
    inline('  MACRO_proceed;'),
    inline('}').
write_var_inline(X) :-
    inline('{'),
    inline('  MACRO_activate;'),
    inline('  const Q q = vm->in[1];'),
    inline('  const A* a = ptr_of<A>(q);'),
    inline('  std::cout << a;'),
    inline('  MACRO_proceed;'),
    inline('}').

integer(X) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_return;'),
    inline('}').

atom(X) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_ATOM, reg::in(1));'),
    inline('  MACRO_return;'),
    inline('}').

var(X) :-
    inline('{'),
    inline('  const Q q = vm->in[1] = deref(vm->in[1]);'),
    inline('  const TAG_T t = tag_of(q);'),
    inline('  if (t != TAG_REF) {'),
    inline('    vm->fail();'),
    inline('    continue;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').
is_functor(X) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_STR, reg::in(1));'),
    inline('  const Q q = vm->in[1];'),
    inline('  const TAG_T t = tag_of(q);'),
    inline('  if (t != TAG_STR) {'),
    inline('    vm->fail();'),
    inline('    continue;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').
'=..'(F, U) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_STR, reg::in(1));'),
    inline('  const Q q = vm->in[1];'),
    inline('  A* p = ptr_of<A>(q);'),
    inline('  const Q Fun = p[0].load();'),
    inline('  const int arity = atom_arity_of(Fun);'),
    inline('  const size_t h = vm->heap_publishing((1 + arity) * 2);'),
    inline('  for (int i = 0; i <= arity; ++i) {'),
    inline('    vm->heap[h + i * 2].store(p[i].load());'),
    inline('    vm->heap[h + i * 2 + 1].store('),
    inline('      (i < arity) ? tagptr<TAG_LIST>(&vm->heap[h + i * 2 + 2]) :'),
    inline('      tagptr<TAG_NIL, Q>(0));'),
    inline('  }'),
    inline('  vm->heap_published((1 + arity) * 2);'),
    inline('  vm->unify(tagptr<TAG_LIST>(&vm->heap[h]), vm->in[2]);'),
    inline('  MACRO_proceed;'),
    inline('}').

X == Y :-
    inline('{'),
    inline('  MACRO_wait(reg::in(1));'),
    inline('  MACRO_wait(reg::in(2));'),
    inline('  Q q1 = vm->in[1];'),
    inline('  Q q2 = vm->in[2];'),
    inline('  if (!(q1 == q2)) {'),
    inline('    MACRO_fail;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').

X >= Y :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  if (!(v1 >= v2)) {'),
    inline('    MACRO_fail;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').

X =< Y :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  if (!(v1 <= v2)) {'),
    inline('    MACRO_fail;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').

X > Y :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  if (!(v1 > v2)) {'),
    inline('    MACRO_fail;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').

X < Y :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  if (!(v1 < v2)) {'),
    inline('    MACRO_fail;'),
    inline('  }'),
    inline('  MACRO_return;'),
    inline('}').

Y := X :- integer(X) | X = Y.
C := -A :- A1 := A -> ineg(A1, C).
C := (A + B) :- A1 := A -> B1 := B -> iadd(A1, B1, C).
C := (A - B) :- A1 := A -> B1 := B -> isub(A1, B1, C).
C := (A * B) :- A1 := A -> B1 := B -> imul(A1, B1, C).
C := (A / B) :- A1 := A -> B1 := B -> idiv(A1, B1, C).
ineg(A, B) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  const int64_t v = -value_of<int64_t>(reg::in(1));'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(v), reg::in(2));'),
    inline('  MACRO_proceed;'),
    inline('}').
iadd(A, B, C) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  const int64_t v = v1 + v2;'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(v), reg::in(3));'),
    inline('  MACRO_proceed;'),
    inline('}').
isub(A, B, C) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  const int64_t v = v1 - v2;'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(v), reg::in(3));'),
    inline('  MACRO_proceed;'),
    inline('}').
imul(A, B, C) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  const int64_t v = v1 * v2;'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(v), reg::in(3));'),
    inline('  MACRO_proceed;'),
    inline('}').
idiv(A, B, C) :-
    inline('{'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(1));'),
    inline('  MACRO_wait_for(TAG_INT, reg::in(2));'),
    inline('  const int64_t v1 = value_of<int64_t>(vm->in[reg::in(1)]);'),
    inline('  const int64_t v2 = value_of<int64_t>(vm->in[reg::in(2)]);'),
    inline('  const int64_t v = v1 / v2;'),
    inline('  MACRO_get_constant(tagvalue<TAG_INT>(v), reg::in(3));'),
    inline('  MACRO_proceed;'),
    inline('}').
